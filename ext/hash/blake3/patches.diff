diff --git a/ext/hash/blake3/upstream_blake3/c/blake3.c b/ext/hash/blake3/upstream_blake3/c/blake3.c
index 692f4b0216..3591ba245a 100644
--- a/ext/hash/blake3/upstream_blake3/c/blake3.c
+++ b/ext/hash/blake3/upstream_blake3/c/blake3.c
@@ -341,21 +341,23 @@ INLINE void compress_subtree_to_parent_node(
   size_t num_cvs = blake3_compress_subtree_wide(input, input_len, key,
                                                 chunk_counter, flags, cv_array);
   assert(num_cvs <= MAX_SIMD_DEGREE_OR_2);
-
-  // If MAX_SIMD_DEGREE is greater than 2 and there's enough input,
-  // compress_subtree_wide() returns more than 2 chaining values. Condense
-  // them into 2 by forming parent nodes repeatedly.
-  uint8_t out_array[MAX_SIMD_DEGREE_OR_2 * BLAKE3_OUT_LEN / 2];
-  // The second half of this loop condition is always true, and we just
+  // https://github.com/BLAKE3-team/BLAKE3/pull/380
+  // This condition is always true, and we just
   // asserted it above. But GCC can't tell that it's always true, and if NDEBUG
   // is set on platforms where MAX_SIMD_DEGREE_OR_2 == 2, GCC emits spurious
   // warnings here. GCC 8.5 is particularly sensitive, so if you're changing
   // this code, test it against that version.
-  while (num_cvs > 2 && num_cvs <= MAX_SIMD_DEGREE_OR_2) {
+#if MAX_SIMD_DEGREE_OR_2 > 2
+  // If MAX_SIMD_DEGREE_OR_2 is greater than 2 and there's enough input,
+  // compress_subtree_wide() returns more than 2 chaining values. Condense
+  // them into 2 by forming parent nodes repeatedly.
+  uint8_t out_array[MAX_SIMD_DEGREE_OR_2 * BLAKE3_OUT_LEN / 2];
+  while (num_cvs > 2) {
     num_cvs =
         compress_parents_parallel(cv_array, num_cvs, key, flags, out_array);
     memcpy(cv_array, out_array, num_cvs * BLAKE3_OUT_LEN);
   }
+#endif
   memcpy(out, cv_array, 2 * BLAKE3_OUT_LEN);
 }
 
diff --git a/ext/hash/blake3/upstream_blake3/c/blake3_dispatch.c b/ext/hash/blake3/upstream_blake3/c/blake3_dispatch.c
index af6c3dadc7..af3bf17bbe 100644
--- a/ext/hash/blake3/upstream_blake3/c/blake3_dispatch.c
+++ b/ext/hash/blake3/upstream_blake3/c/blake3_dispatch.c
@@ -86,7 +86,6 @@ static void cpuidex(uint32_t out[4], uint32_t id, uint32_t sid) {
 #endif
 }
 
-#endif
 
 enum cpu_feature {
   SSE2 = 1 << 0,
@@ -161,6 +160,8 @@ static
 #endif
   }
 }
+// https://github.com/BLAKE3-team/BLAKE3/pull/382
+#endif
 
 void blake3_compress_in_place(uint32_t cv[8],
                               const uint8_t block[BLAKE3_BLOCK_LEN],
diff --git a/ext/hash/blake3/upstream_blake3/c/blake3_neon.c b/ext/hash/blake3/upstream_blake3/c/blake3_neon.c
index 8a818fc78f..c4b4548edf 100644
--- a/ext/hash/blake3/upstream_blake3/c/blake3_neon.c
+++ b/ext/hash/blake3/upstream_blake3/c/blake3_neon.c
@@ -9,15 +9,13 @@
 #endif
 
 INLINE uint32x4_t loadu_128(const uint8_t src[16]) {
-  // vld1q_u32 has alignment requirements. Don't use it.
-  uint32x4_t x;
-  memcpy(&x, src, 16);
-  return x;
+    // https://github.com/BLAKE3-team/BLAKE3/pull/384
+    return vreinterpretq_u32_u8(vld1q_u8(src));
 }
 
 INLINE void storeu_128(uint32x4_t src, uint8_t dest[16]) {
-  // vst1q_u32 has alignment requirements. Don't use it.
-  memcpy(dest, &src, 16);
+    // https://github.com/BLAKE3-team/BLAKE3/pull/384
+    vst1q_u8(dest, vreinterpretq_u8_u32(src));
 }
 
 INLINE uint32x4_t add_128(uint32x4_t a, uint32x4_t b) {
